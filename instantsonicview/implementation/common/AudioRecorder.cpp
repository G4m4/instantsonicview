/// @filename AudioRecorder.cpp
/// @brief InstantSonicView meter widgets manager
/// @author gm
/// @copyright gm 2014
///
/// This file is part of InstantSonicView
///
/// InstantSonicView is free software: you can redistribute it and/or modify
/// it under the terms of the GNU General Public License as published by
/// the Free Software Foundation, either version 3 of the License, or
/// (at your option) any later version.
///
/// InstantSonicView is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with InstantSonicView.  If not, see <http://www.gnu.org/licenses/>.


// This file is NOT generated by Juce (at least not after the first time),
// That's why we apply our coding style here

#include "instantsonicview/implementation/common/AudioRecorder.h"

#include "instantsonicview/implementation/plugin/vst/PluginProcessor.h"

AudioRecorder::AudioRecorder ()
    : backgroundThread("Audio Recorder Thread"),
      buffer_(),
      activeWriter(nullptr),
      active_reader_(nullptr),
      reader_samples_num_(0) {
  backgroundThread.startThread();
}

AudioRecorder::~AudioRecorder() {
  stopRecording();
  stopReplay();
}

void AudioRecorder::startRecording(double sample_rate) {
  stopRecording();

  if (sample_rate > 0) {
    // Create an OutputStream to write to our destination memory block...
    ScopedPointer<MemoryOutputStream> memStream(new juce::MemoryOutputStream(buffer_, false));

    if (memStream != nullptr) {
      // Now create a WAV writer object that writes to our output stream...
      WavAudioFormat wavFormat;
      AudioFormatWriter* writer = wavFormat.createWriterFor(memStream, sample_rate, 1, 16, StringPairArray(), 0);

      if (writer != nullptr) {
        memStream.release(); // (passes responsibility for deleting the stream to the writer object that is now using it)

        // Now we'll create one of these helper objects which will act as a FIFO buffer, and will
        // write the data to disk on our background thread.
        threadedWriter = new AudioFormatWriter::ThreadedWriter (writer, backgroundThread, 32768);

        // And now, swap over our active writer pointer so that the audio callback will start using it..
        const ScopedLock sl (writerLock);
        activeWriter = threadedWriter;
      }
    }
  }  // (sample_rate > 0)?
}

void AudioRecorder::stopRecording(void) {
  // First, clear this pointer to stop the audio callback from using our writer object..
  {
    const ScopedLock sl (writerLock);
    activeWriter = nullptr;
  }

  // Now we can delete the writer object. It's done in this order because the deletion could
  // take a little time while remaining data gets flushed to disk, so it's best to avoid blocking
  // the audio callback while this happens.
  threadedWriter = nullptr;
}

void AudioRecorder::startReplay(void) {
  stopReplay();

  ScopedPointer<MemoryInputStream> memStream(new juce::MemoryInputStream(buffer_, false));

  if (memStream != nullptr) {
    // Now create a WAV writer object that writes to our output stream...
    juce::WavAudioFormat wavFormat;
    juce::AudioFormatReader* reader = wavFormat.createReaderFor(memStream, true);

    if (reader != nullptr) {
      memStream.release(); // (passes responsibility for deleting the stream to the writer object that is now using it)
      active_reader_ = reader;
      reader_samples_num_ = 0;
    }
  }
}

void AudioRecorder::stopReplay(void) {
  delete active_reader_;
  active_reader_ = nullptr;
}

bool AudioRecorder::isReplaying() const {
  return active_reader_ != nullptr;
}

bool AudioRecorder::isRecording() const {
  return activeWriter != nullptr;
}

void AudioRecorder::AudioCallback(const juce::AudioSampleBuffer& buffer) {
  const ScopedLock sl (writerLock);

  if (activeWriter != nullptr) {
    activeWriter->write(buffer.getArrayOfReadPointers(), buffer.getNumSamples());
  }
}

bool AudioRecorder::GetNextReplayBlock(juce::AudioSampleBuffer* dest) {
  if (active_reader_ == nullptr) {
    return false;
  } else {
    if (reader_samples_num_ > active_reader_->lengthInSamples) {
      stopReplay();
      return false;
    } else {
      active_reader_->read(dest,
                           0,
                           dest->getNumSamples(),
                           reader_samples_num_,
                           true,
                           false);
      reader_samples_num_ += dest->getNumSamples();
      return true;
    }
  }
}
