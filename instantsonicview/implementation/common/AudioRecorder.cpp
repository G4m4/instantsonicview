/// @filename AudioRecorder.cpp
/// @brief InstantSonicView meter widgets manager
/// @author gm
/// @copyright gm 2014
///
/// This file is part of InstantSonicView
///
/// InstantSonicView is free software: you can redistribute it and/or modify
/// it under the terms of the GNU General Public License as published by
/// the Free Software Foundation, either version 3 of the License, or
/// (at your option) any later version.
///
/// InstantSonicView is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with InstantSonicView.  If not, see <http://www.gnu.org/licenses/>.


// This file is NOT generated by Juce (at least not after the first time),
// That's why we apply our coding style here

#include "instantsonicview/implementation/common/AudioRecorder.h"

#include "instantsonicview/implementation/plugin/vst/PluginProcessor.h"

AudioRecorder::AudioRecorder ()
    : float_buffer_(),
      current_writing_cursor_(0),
      current_reading_cursor_(0),
      is_writing_(false),
      is_reading_(false) {
  // Nothing to do here for now
}

AudioRecorder::~AudioRecorder() {
  stopRecording();
  stopReplay();
}

void AudioRecorder::startRecording(double sample_rate) {
  stopRecording();

  if (sample_rate > 0) {
    current_writing_cursor_ = 0;
    is_writing_ = true;
  }  // (sample_rate > 0)?
}

void AudioRecorder::stopRecording(void) {
  float_buffer_.setSize(current_writing_cursor_);
  is_writing_ = false;
}

void AudioRecorder::startReplay(void) {
  stopReplay();

  is_reading_ = true;
  current_reading_cursor_ = 0;
}

void AudioRecorder::stopReplay(void) {
  is_reading_ = false;
}

bool AudioRecorder::isReplaying() const {
  return is_reading_;
}

bool AudioRecorder::isRecording() const {
  return is_writing_;
}

void AudioRecorder::AudioCallback(const juce::AudioSampleBuffer& buffer) {
  if (isRecording()) {
    float_buffer_.insert(buffer.getReadPointer(0),
                         buffer.getNumSamples() * sizeof(float),
                         current_writing_cursor_);
    current_writing_cursor_ += buffer.getNumSamples() * sizeof(float);
  }
}

bool AudioRecorder::GetNextReplayBlock(juce::AudioSampleBuffer* dest) {
  if (!isReplaying()) {
    return false;
  } else {
    if (current_reading_cursor_ >= current_writing_cursor_) {
      stopReplay();
      return false;
    } else {
      const unsigned int kNumSamples(dest->getNumSamples());
      dest->clear();
      const float* kAudioData(static_cast<float*>(float_buffer_.getData())
                              + current_reading_cursor_ / sizeof(float));
      dest->addFrom(0, 0, kAudioData, kNumSamples);
      current_reading_cursor_ += kNumSamples * sizeof(float);
      return true;
    }
  }
}

unsigned int AudioRecorder::GetAudioDataLength(void) const {
  return float_buffer_.getSize() / sizeof(float);
}

const float* AudioRecorder::GetAudioData(void) const {
  return static_cast<float*>(float_buffer_.getData());
}
