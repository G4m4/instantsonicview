/// @filename AudioRecorder.cpp
/// @brief InstantSonicView meter widgets manager
/// @author gm
/// @copyright gm 2014
///
/// This file is part of InstantSonicView
///
/// InstantSonicView is free software: you can redistribute it and/or modify
/// it under the terms of the GNU General Public License as published by
/// the Free Software Foundation, either version 3 of the License, or
/// (at your option) any later version.
///
/// InstantSonicView is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with InstantSonicView.  If not, see <http://www.gnu.org/licenses/>.


// This file is NOT generated by Juce (at least not after the first time),
// That's why we apply our coding style here

#include "instantsonicview/implementation/common/AudioRecorder.h"

#include "instantsonicview/implementation/plugin/vst/PluginProcessor.h"

AudioRecorder::AudioRecorder (AudioThumbnail& thumbnailToUpdate)
    : thumbnail (thumbnailToUpdate),
      backgroundThread("Audio Recorder Thread"),
      nextSampleNum(0),
      activeWriter(nullptr) {
  backgroundThread.startThread();
}

AudioRecorder::~AudioRecorder() {
  stop();
}

void AudioRecorder::startRecording(const File& file, double sample_rate) {
  stop();

  if (sample_rate > 0) {
    // Create an OutputStream to write to our destination file...
    file.deleteFile();
    ScopedPointer<FileOutputStream> fileStream (file.createOutputStream());

    if (fileStream != nullptr) {
      // Now create a WAV writer object that writes to our output stream...
      WavAudioFormat wavFormat;
      AudioFormatWriter* writer = wavFormat.createWriterFor (fileStream, sample_rate, 1, 16, StringPairArray(), 0);

      if (writer != nullptr) {
        fileStream.release(); // (passes responsibility for deleting the stream to the writer object that is now using it)

        // Now we'll create one of these helper objects which will act as a FIFO buffer, and will
        // write the data to disk on our background thread.
        threadedWriter = new AudioFormatWriter::ThreadedWriter (writer, backgroundThread, 32768);

        // Reset our recording thumbnail
        thumbnail.reset (writer->getNumChannels(), writer->getSampleRate());
        nextSampleNum = 0;

        // And now, swap over our active writer pointer so that the audio callback will start using it..
        const ScopedLock sl (writerLock);
        activeWriter = threadedWriter;
      }
    }
  }
}

void AudioRecorder::stop() {
  // First, clear this pointer to stop the audio callback from using our writer object..
  {
    const ScopedLock sl (writerLock);
    activeWriter = nullptr;
  }

  // Now we can delete the writer object. It's done in this order because the deletion could
  // take a little time while remaining data gets flushed to disk, so it's best to avoid blocking
  // the audio callback while this happens.
  threadedWriter = nullptr;
}

bool AudioRecorder::isRecording() const {
  return activeWriter != nullptr;
}

void AudioRecorder::changeListenerCallback(ChangeBroadcaster* source) {
  const InstantSonicViewAudioProcessor* proc(dynamic_cast<const InstantSonicViewAudioProcessor*>(source));
  assert(proc != nullptr);
  const ScopedLock sl (writerLock);

  if (activeWriter != nullptr) {
    activeWriter->write(proc->GetLastBuffer().getArrayOfReadPointers(), proc->GetLastBuffer().getNumSamples());

    thumbnail.addBlock (nextSampleNum, proc->GetLastBuffer(), 0, proc->GetLastBuffer().getNumSamples());
    nextSampleNum += proc->GetLastBuffer().getNumSamples();
  }
}
